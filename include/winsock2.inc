ifndef __LIBC_INC
 include libc.inc
endif
ifndef _WINSOCK2API_
_WINSOCK2API_ equ <>
_WINSOCKAPI_  equ <>

include winapifamily.inc

ifndef _WINSOCK_DEPRECATED_BY
if ((defined(_WINSOCK_DEPRECATED_NO_WARNINGS) or defined(BUILD_WINDOWS)) and not defined(_WINSOCK_DEPRECATE_WARNINGS)) or defined(MIDL_PASS)
_WINSOCK_DEPRECATED_BY macro replacement
	endm
else
_WINSOCK_DEPRECATED_BY macro replacement
	exitm<"Use &replacement& instead or define _WINSOCK_DEPRECATED_NO_WARNINGS to disable deprecated API warnings">
	endm
endif
endif

ifndef _WINSOCK_DEPRECATED
if ((defined(_WINSOCK_DEPRECATED_NO_WARNINGS) or defined(BUILD_WINDOWS)) and not defined(_WINSOCK_DEPRECATE_WARNINGS)) or defined(MIDL_PASS)
_WINSOCK_DEPRECATED macro
	endm
else
_WINSOCK_DEPRECATED macro
	.out <"Define _WINSOCK_DEPRECATED_NO_WARNINGS to disable deprecated API warnings">
	endm
endif
endif

ifndef INCL_WINSOCK_API_PROTOTYPES
INCL_WINSOCK_API_PROTOTYPES equ 1
endif

ifndef INCL_WINSOCK_API_TYPEDEFS
INCL_WINSOCK_API_TYPEDEFS equ 0
endif

ifndef _INC_WINDOWS
include windows.inc
endif

if (not defined(_WIN64) and not defined(WIN32))
.pragma pack(push, 4)
_NEED_POPPACK equ 1
endif


ifndef MAKEWORD
MAKEWORD macro low,high
	exitm<((low) OR ((high) SHL 8))>
	endm
endif

ifndef WINSOCK_VERSION
WINSOCK_VERSION		equ MAKEWORD(2,2)
endif


ifndef WINSOCK_API_LINKAGE
ifdef DECLSPEC_IMPORT
WINSOCK_API_LINKAGE	equ DECSPEC_IMPORT
else
WINSOCK_API_LINKAGE	equ 1
endif
endif

u_char			typedef byte
u_short			typedef word
u_int			typedef sdword
u_long			typedef dword
if(_WIN32_WINNT GE 0x0501)
u_int64			typedef sqword
endif

include ws2def.inc
.pragma comment(lib, Ws2_32)

SOCKET			typedef UINT_PTR

ifndef FD_SETSIZE
FD_SETSIZE		equ 64
endif

fd_set			STRUC
fd_count		UINT ?
fd_array		SOCKET FD_SETSIZE dup(?)
fd_set			ENDS

__WSAFDIsSet		proto :SOCKET, :ptr fd_set

FD_CLR macro fd, set
  local __i
ifdef _WIN64
    __i equ <rbx>
else
    __i equ <ebx>
endif
    push __i
    .for ( __i = 0 : __i < set.fd_set.fd_count : __i++ )

	.if ( set.fd_set.fd_array[__i*4] == fd )

	    .while 1

		mov eax,set.fd_set.fd_count
		dec eax
		.break .if eax < __i

		mov eax,set.fd_set.fd_array[__i*4+4]
		mov set.fd_set.fd_array[__i*4],eax
		inc __i

	    .endw

	    dec set.fd_set.fd_count
	    .break

	.endif
    .endf
    pop __i
    endm

FD_SET macro fd, set
  local __i
ifdef _WIN64
    __i equ <rax>
else
    __i equ <eax>
endif
    .for ( __i = 0 : __i < set.fd_set.fd_count : __i++ )
	.break .if ( set.fd_set.fd_array[__i*4] == fd )
    .endf
    .if ( __i == set.fd_set.fd_count )
	.if ( set.fd_set.fd_count < FD_SETSIZE )
	    mov set.fd_set.fd_array[__i*4],fd
	    inc set.fd_set.fd_count
	.endif
    .endif
    endm

FD_ZERO macro set
	lea eax, set
	mov [eax].fd_set.fd_count,0
	endm

FD_ISSET macro fd, set
	exitm<__WSAFDIsSet(fd, set)>
	endm

timeval		STRUC
tv_sec		LONG ?
tv_usec		LONG ?
timeval		ENDS

timerisset macro tvp
	exitm<(tvp.tv_sec || tvp.tv_usec)>
	endm
timercmp macro tvp, uvp, op
	exitm<(tvp.tv_sec op uvp.tv_sec || tvp.tv_sec == uvp.tv_sec && tvp.tv_usec cm uvp.tv_usec)>
	endm
timerclear macro tvp
	mov tvp.tv_sec,0
	mov tvp.tv_usec,0
	exitm<>
	endm

IOCPARM_MASK		equ 0x7f
IOC_VOID		equ 0x20000000
IOC_OUT			equ 0x40000000
IOC_IN			equ 0x80000000
IOC_INOUT		equ (IOC_IN OR IOC_OUT)

_IO macro x,y
	exitm<(IOC_VOID OR ((x) SHL 8) OR (y))>
	endm

_IOR macro x,y,t
	exitm<(IOC_OUT OR ((sizeof(t) AND IOCPARM_MASK) SHL 16) OR ((x) SHL 8) OR (y))>
	endm

_IOW macro x,y,t
	exitm<(IOC_IN OR ((sizeof(t) AND IOCPARM_MASK) SHL 16) OR ((x) SHL 8) OR (y))>
	endm

FIONREAD		equ _IOR('f', 127, DWORD)
FIONBIO			equ _IOW('f', 126, DWORD)
FIOASYNC		equ _IOW('f', 125, DWORD)

SIOCSHIWAT		equ _IOW('s',  0, DWORD)
SIOCGHIWAT		equ _IOR('s',  1, DWORD)
SIOCSLOWAT		equ _IOW('s',  2, DWORD)
SIOCGLOWAT		equ _IOR('s',  3, DWORD)
SIOCATMARK		equ _IOR('s',  7, DWORD)


hostent			STRUC
h_name			LPSTR ?
h_aliases		LPSTR ?
h_addrtype		dw ?
h_length		dw ?
h_addr_list		LPSTR ?
;h_addr			equ <h_addr_list[0]> ; address, for backward compat
hostent			ENDS

netent			STRUC
n_name			LPSTR ?
n_aliases		LPSTR ?
n_addrtype		dw ?
n_net			dd ?
netent			ENDS

servent			STRUC
s_name			LPSTR ?
s_aliases		LPSTR ?
ifdef _WIN64
s_proto			LPSTR ?
s_port			dw ?
else
s_port			dw ?
s_proto			LPSTR ?
endif
servent			ENDS

protoent		STRUC
p_name			LPSTR ?
p_aliases		LPSTR ?
p_proto			dw ?
protoent		ENDS


IPPROTO_IP		equ 0
IPPROTO_ICMP		equ 1
IPPROTO_IGMP		equ 2
IPPROTO_GGP		equ 3
IPPROTO_TCP		equ 6
IPPROTO_PUP		equ 12
IPPROTO_UDP		equ 17
IPPROTO_IDP		equ 22
IPPROTO_ND		equ 77

IPPROTO_RAW		equ 255
IPPROTO_MAX		equ 256

IPPORT_ECHO		equ 7
IPPORT_DISCARD		equ 9
IPPORT_SYSTAT		equ 11
IPPORT_DAYTIME		equ 13
IPPORT_NETSTAT		equ 15
IPPORT_FTP		equ 21
IPPORT_TELNET		equ 23
IPPORT_SMTP		equ 25
IPPORT_TIMESERVER	equ 37
IPPORT_NAMESERVER	equ 42
IPPORT_WHOIS		equ 43
IPPORT_MTP		equ 57

IPPORT_TFTP		equ 69
IPPORT_RJE		equ 77
IPPORT_FINGER		equ 79
IPPORT_TTYLINK		equ 87
IPPORT_SUPDUP		equ 95

IPPORT_EXECSERVER	equ 512
IPPORT_LOGINSERVER	equ 513
IPPORT_CMDSERVER	equ 514
IPPORT_EFSSERVER	equ 520

IPPORT_BIFFUDP		equ 512
IPPORT_WHOSERVER	equ 513
IPPORT_ROUTESERVER	equ 520

IPPORT_RESERVED		equ 1024

IMPLINK_IP		equ 155
IMPLINK_LOWEXPER	equ 156
IMPLINK_HIGHEXPER	equ 158

in_addr			STRUC
UNION S_un
    STRUC S_un_b
	s_b1		db ?
	s_b2		db ?
	s_b3		db ?
	s_b4		db ?
    ENDS
    STRUC S_un_w
	s_w1		dw ?
	s_w2		dw ?
    ENDS
    S_addr		dd ?
ENDS
;s_addr			equ <S_un.S_addr>
;s_host			equ <S_un.S_un_b.s_b2>
;s_net			equ <S_un.S_un_b.s_b1>
;s_imp			equ <S_un.S_un_w.s_w2>
;s_impno			equ <S_un.S_un_b.s_b4>
;s_lh			equ <S_un.S_un_b.s_b3>
in_addr			ENDS

IN_CLASSA macro i
	exitm<(((i) AND 0x80000000) EQ 0)>
	endm
IN_CLASSA_NET		equ 0xff000000
IN_CLASSA_NSHIFT	equ 24
IN_CLASSA_HOST		equ 0x00ffffff
IN_CLASSA_MAX		equ 128

IN_CLASSB macro i
	exitm<(((i) AND 0xc0000000) EQ 0x80000000)>
	endm
IN_CLASSB_NET		equ 0xffff0000
IN_CLASSB_NSHIFT	equ 16
IN_CLASSB_HOST		equ 0x0000ffff
IN_CLASSB_MAX		equ 65536

IN_CLASSC macro i
	exitm<(((i) AND 0xe0000000) EQ 0xc0000000)>
	endm
IN_CLASSC_NET		equ 0xffffff00
IN_CLASSC_NSHIFT	equ 8
IN_CLASSC_HOST		equ 0x000000ff

IN_CLASSD macro i
	exitm<(((i) AND 0xf0000000) EQ 0xe0000000)>
	endm
IN_CLASSD_NET		equ 0xf0000000
IN_CLASSD_NSHIFT	equ 28
IN_CLASSD_HOST		equ 0x0fffffff
IN_MULTICAST macro i
	exitm<IN_CASSD(i)>
	endm

INADDR_ANY		equ 0x00000000
INADDR_LOOPBACK		equ 0x7f000001
INADDR_BROADCAST	equ 0xffffffff
INADDR_NONE		equ 0xffffffff

ADDR_ANY		equ INADDR_ANY

sockaddr_in		STRUC
sin_family		dw ?
sin_port		dw ?
sin_addr		PVOID ?
sin_zero		db 8 dup(?)
sockaddr_in		ENDS

WSADESCRIPTION_LEN	equ 256
WSASYS_STATUS_LEN	equ 128

WSADATA			STRUC
wVersion		dw ?
wHighVersion		dw ?
ifdef _WIN64
iMaxSockets		dw ?
iMaxUdpDg		dw ?
lpVendorInfo		LPSTR ?
szDescription		db WSADESCRIPTION_LEN+1 dup(?)
szSystemStatus		db WSASYS_STATUS_LEN+1 dup(?)
else
szDescription		db WSADESCRIPTION_LEN+1 dup(?)
szSystemStatus		db WSASYS_STATUS_LEN+1 dup(?)
iMaxSockets		dw ?
iMaxUdpDg		dw ?
lpVendorInfo		LPSTR ?
endif
WSADATA			ENDS
LPWSADATA		typedef ptr WSADATA

INVALID_SOCKET		equ <NOT 0>
SOCKET_ERROR		equ (-1)

FROM_PROTOCOL_INFO	equ (-1)

SOCK_STREAM		equ 1
SOCK_DGRAM		equ 2
SOCK_RAW		equ 3
SOCK_RDM		equ 4
SOCK_SEQPACKET		equ 5

SO_DEBUG		equ 0x0001
SO_ACCEPTCONN		equ 0x0002
SO_REUSEADDR		equ 0x0004
SO_KEEPALIVE		equ 0x0008
SO_DONTROUTE		equ 0x0010
SO_BROADCAST		equ 0x0020
SO_USELOOPBACK		equ 0x0040
SO_LINGER		equ 0x0080
SO_OOBINLINE		equ 0x0100

SO_DONTLINGER		equ <not SO_LINGER>

SO_SNDBUF		equ 0x1001
SO_RCVBUF		equ 0x1002
SO_SNDLOWAT		equ 0x1003
SO_RCVLOWAT		equ 0x1004
SO_SNDTIMEO		equ 0x1005
SO_RCVTIMEO		equ 0x1006
SO_ERROR		equ 0x1007
SO_TYPE			equ 0x1008

SO_GROUP_ID		equ 0x2001
SO_GROUP_PRIORITY	equ 0x2002
SO_MAX_MSG_SIZE		equ 0x2003
SO_PROTOCOL_INFOA	equ 0x2004
SO_PROTOCOL_INFOW	equ 0x2005
ifdef _UNICODE
SO_PROTOCOL_INFO	equ SO_PROTOCOL_INFOW
else
SO_PROTOCOL_INFO	equ SO_PROTOCOL_INFOA
endif
PVD_CONFIG		equ 0x3001
SO_CONDITIONAL_ACCEPT	equ 0x3002

sockproto		STRUC
sp_family		dw ?
sp_protocol		dw ?
sockproto		ENDS

PF_UNSPEC		equ AF_UNSPEC
PF_UNIX			equ AF_UNIX
PF_INET			equ AF_INET
PF_IMPLINK		equ AF_IMPLINK
PF_PUP			equ AF_PUP
PF_CHAOS		equ AF_CHAOS
PF_NS			equ AF_NS
PF_IPX			equ AF_IPX
PF_ISO			equ AF_ISO
PF_OSI			equ AF_OSI
PF_ECMA			equ AF_ECMA
PF_DATAKIT		equ AF_DATAKIT
PF_CCITT		equ AF_CCITT
PF_SNA			equ AF_SNA
PF_DECnet		equ AF_DECnet
PF_DLI			equ AF_DI
PF_LAT			equ AF_LAT
PF_HYLINK		equ AF_HYLINK
PF_APPLETALK		equ AF_APPLETAK
PF_VOICEVIEW		equ AF_VOICEVIEW
PF_FIREFOX		equ AF_FIREFOX
PF_UNKNOWN1		equ AF_UNKNOWN1
PF_BAN			equ AF_BAN
PF_ATM			equ AF_ATM
PF_INET6		equ AF_INET6
if(_WIN32_WINNT GE 0x0600)
PF_BTH			equ AF_BTH
endif
PF_MAX			equ AF_MAX

linger			STRUC
l_onoff			dw ?
l_linger		dw ?
linger			ENDS

SOL_SOCKET		equ 0xffff

SOMAXCONN		equ 0x7fffffff

MSG_OOB			equ 0x1
MSG_PEEK		equ 0x2
MSG_DONTROUTE		equ 0x4
if(_WIN32_WINNT GE 0x0502)
MSG_WAITALL		equ 0x8
endif
if(_WIN32_WINNT GE 0x0603)
MSG_PUSH_IMMEDIATE	equ 0x20
endif

MSG_PARTIAL		equ 0x8000
MSG_INTERRUPT		equ 0x10
MSG_MAXIOVLEN		equ 16

MAXGETHOSTSTRUCT	equ 1024

FD_READ_BIT		equ 0
FD_READ			equ (1 SHL FD_READ_BIT)
FD_WRITE_BIT		equ 1
FD_WRITE		equ (1 SHL FD_WRITE_BIT)
FD_OOB_BIT		equ 2
FD_OOB			equ (1 SHL FD_OOB_BIT)
FD_ACCEPT_BIT		equ 3
FD_ACCEPT		equ (1 SHL FD_ACCEPT_BIT)
FD_CONNECT_BIT		equ 4
FD_CONNECT		equ (1 SHL FD_CONNECT_BIT)
FD_CLOSE_BIT		equ 5
FD_CLOSE		equ (1 SHL FD_COSE_BIT)
FD_QOS_BIT		equ 6
FD_QOS			equ (1 SHL FD_QOS_BIT)
FD_GROUP_QOS_BIT	equ 7
FD_GROUP_QOS		equ (1 SHL FD_GROUP_QOS_BIT)
FD_ROUTING_INTERFACE_CHANGE_BIT equ 8
FD_ROUTING_INTERFACE_CHANGE equ (1 SHL FD_ROUTING_INTERFACE_CHANGE_BIT)
FD_ADDRESS_LIST_CHANGE_BIT equ 9
FD_ADDRESS_LIST_CHANGE	equ (1 SHL FD_ADDRESS_LIST_CHANGE_BIT)
FD_MAX_EVENTS		equ 10
FD_ALL_EVENTS		equ ((1 SHL FD_MAX_EVENTS) - 1)

ifndef WSABASEERR

WSABASEERR		equ 10000
WSAEINTR		equ (WSABASEERR+4)
WSAEBADF		equ (WSABASEERR+9)
WSAEACCES		equ (WSABASEERR+13)
WSAEFAULT		equ (WSABASEERR+14)
WSAEINVAL		equ (WSABASEERR+22)
WSAEMFILE		equ (WSABASEERR+24)

WSAEWOULDBLOCK		equ (WSABASEERR+35)
WSAEINPROGRESS		equ (WSABASEERR+36)
WSAEALREADY		equ (WSABASEERR+37)
WSAENOTSOCK		equ (WSABASEERR+38)
WSAEDESTADDRREQ		equ (WSABASEERR+39)
WSAEMSGSIZE		equ (WSABASEERR+40)
WSAEPROTOTYPE		equ (WSABASEERR+41)
WSAENOPROTOOPT		equ (WSABASEERR+42)
WSAEPROTONOSUPPORT	equ (WSABASEERR+43)
WSAESOCKTNOSUPPORT	equ (WSABASEERR+44)
WSAEOPNOTSUPP		equ (WSABASEERR+45)
WSAEPFNOSUPPORT		equ (WSABASEERR+46)
WSAEAFNOSUPPORT		equ (WSABASEERR+47)
WSAEADDRINUSE		equ (WSABASEERR+48)
WSAEADDRNOTAVAIL	equ (WSABASEERR+49)
WSAENETDOWN		equ (WSABASEERR+50)
WSAENETUNREACH		equ (WSABASEERR+51)
WSAENETRESET		equ (WSABASEERR+52)
WSAECONNABORTED		equ (WSABASEERR+53)
WSAECONNRESET		equ (WSABASEERR+54)
WSAENOBUFS		equ (WSABASEERR+55)
WSAEISCONN		equ (WSABASEERR+56)
WSAENOTCONN		equ (WSABASEERR+57)
WSAESHUTDOWN		equ (WSABASEERR+58)
WSAETOOMANYREFS		equ (WSABASEERR+59)
WSAETIMEDOUT		equ (WSABASEERR+60)
WSAECONNREFUSED		equ (WSABASEERR+61)
WSAELOOP		equ (WSABASEERR+62)
WSAENAMETOOLONG		equ (WSABASEERR+63)
WSAEHOSTDOWN		equ (WSABASEERR+64)
WSAEHOSTUNREACH		equ (WSABASEERR+65)
WSAENOTEMPTY		equ (WSABASEERR+66)
WSAEPROCLIM		equ (WSABASEERR+67)
WSAEUSERS		equ (WSABASEERR+68)
WSAEDQUOT		equ (WSABASEERR+69)
WSAESTALE		equ (WSABASEERR+70)
WSAEREMOTE		equ (WSABASEERR+71)

WSASYSNOTREADY		equ (WSABASEERR+91)
WSAVERNOTSUPPORTED	equ (WSABASEERR+92)
WSANOTINITIALISED	equ (WSABASEERR+93)
WSAEDISCON		equ (WSABASEERR+101)
WSAENOMORE		equ (WSABASEERR+102)
WSAECANCELLED		equ (WSABASEERR+103)
WSAEINVALIDPROCTABLE	equ (WSABASEERR+104)
WSAEINVALIDPROVIDER	equ (WSABASEERR+105)
WSAEPROVIDERFAILEDINIT	equ (WSABASEERR+106)
WSASYSCALLFAILURE	equ (WSABASEERR+107)
WSASERVICE_NOT_FOUND	equ (WSABASEERR+108)
WSATYPE_NOT_FOUND	equ (WSABASEERR+109)
WSA_E_NO_MORE		equ (WSABASEERR+110)
WSA_E_CANCELLED		equ (WSABASEERR+111)
WSAEREFUSED		equ (WSABASEERR+112)


h_errno			equ <WSAGetLastError()>

WSAHOST_NOT_FOUND	equ (WSABASEERR+1001)
HOST_NOT_FOUND		equ WSAHOST_NOT_FOUND

WSATRY_AGAIN		equ (WSABASEERR+1002)
TRY_AGAIN		equ WSATRY_AGAIN

WSANO_RECOVERY		equ (WSABASEERR+1003)
NO_RECOVERY		equ WSANO_RECOVERY

WSANO_DATA		equ (WSABASEERR+1004)
NO_DATA			equ WSANO_DATA

WSANO_ADDRESS		equ WSANO_DATA
NO_ADDRESS		equ WSANO_ADDRESS

WSA_QOS_RECEIVERS	equ (WSABASEERR + 1005)
WSA_QOS_SENDERS		equ (WSABASEERR + 1006)
WSA_QOS_NO_SENDERS	equ (WSABASEERR + 1007)
WSA_QOS_NO_RECEIVERS	equ (WSABASEERR + 1008)
WSA_QOS_REQUEST_CONFIRMED equ (WSABASEERR + 1009)
WSA_QOS_ADMISSION_FAILURE equ (WSABASEERR + 1010)
WSA_QOS_POLICY_FAILURE	equ (WSABASEERR + 1011)
WSA_QOS_BAD_STYLE	equ (WSABASEERR + 1012)
WSA_QOS_BAD_OBJECT	equ (WSABASEERR + 1013)
WSA_QOS_TRAFFIC_CTRL_ERROR equ (WSABASEERR + 1014)
WSA_QOS_GENERIC_ERROR	equ (WSABASEERR + 1015)

WSA_QOS_ESERVICETYPE	equ (WSABASEERR + 1016)
WSA_QOS_EFLOWSPEC	equ (WSABASEERR + 1017)
WSA_QOS_EPROVSPECBUF	equ (WSABASEERR + 1018)
WSA_QOS_EFILTERSTYLE	equ (WSABASEERR + 1019)
WSA_QOS_EFILTERTYPE	equ (WSABASEERR + 1020)
WSA_QOS_EFILTERCOUNT	equ (WSABASEERR + 1021)
WSA_QOS_EOBJLENGTH	equ (WSABASEERR + 1022)
WSA_QOS_EFLOWCOUNT	equ (WSABASEERR + 1023)
WSA_QOS_EUNKOWNPSOBJ	equ (WSABASEERR + 1024)
WSA_QOS_EPOLICYOBJ	equ (WSABASEERR + 1025)
WSA_QOS_EFLOWDESC	equ (WSABASEERR + 1026)
WSA_QOS_EPSFLOWSPEC	equ (WSABASEERR + 1027)
WSA_QOS_EPSFILTERSPEC	equ (WSABASEERR + 1028)
WSA_QOS_ESDMODEOBJ	equ (WSABASEERR + 1029)
WSA_QOS_ESHAPERATEOBJ	equ (WSABASEERR + 1030)
WSA_QOS_RESERVED_PETYPE equ (WSABASEERR + 1031)

endif

if 0
EWOULDBLOCK		equ WSAEWOULDBOCK
EINPROGRESS		equ WSAEINPROGRESS
EALREADY		equ WSAEAREADY
ENOTSOCK		equ WSAENOTSOCK
EDESTADDRREQ		equ WSAEDESTADDRREQ
EMSGSIZE		equ WSAEMSGSIZE
EPROTOTYPE		equ WSAEPROTOTYPE
ENOPROTOOPT		equ WSAENOPROTOOPT
EPROTONOSUPPORT		equ WSAEPROTONOSUPPORT
ESOCKTNOSUPPORT		equ WSAESOCKTNOSUPPORT
EOPNOTSUPP		equ WSAEOPNOTSUPP
EPFNOSUPPORT		equ WSAEPFNOSUPPORT
EAFNOSUPPORT		equ WSAEAFNOSUPPORT
EADDRINUSE		equ WSAEADDRINUSE
EADDRNOTAVAIL		equ WSAEADDRNOTAVAIL
ENETDOWN		equ WSAENETDOWN
ENETUNREACH		equ WSAENETUNREACH
ENETRESET		equ WSAENETRESET
ECONNABORTED		equ WSAECONNABORTED
ECONNRESET		equ WSAECONNRESET
ENOBUFS			equ WSAENOBUFS
EISCONN			equ WSAEISCONN
ENOTCONN		equ WSAENOTCONN
ESHUTDOWN		equ WSAESHUTDOWN
ETOOMANYREFS		equ WSAETOOMANYREFS
ETIMEDOUT		equ WSAETIMEDOUT
ECONNREFUSED		equ WSAECONNREFUSED
ELOOP			equ WSAEOOP
ENAMETOOLONG		equ WSAENAMETOOLONG
EHOSTDOWN		equ WSAEHOSTDOWN
EHOSTUNREACH		equ WSAEHOSTUNREACH
ENOTEMPTY		equ WSAENOTEMPTY
EPROCLIM		equ WSAEPROCIM
EUSERS			equ WSAEUSERS
EDQUOT			equ WSAEDQUOT
ESTALE			equ WSAESTAE
EREMOTE			equ WSAEREMOTE
endif


if defined(_WIN32) or defined(_WIN64)

WSAAPI			equ <>
WSAEVENT		equ <HANDLE>
LPWSAEVENT		equ <LPHANDE>
WSAOVERLAPPED		equ <OVERLAPPED>
LPWSAOVERLAPPED		typedef ptr OVERLAPPED

WSA_IO_PENDING		equ ERROR_IO_PENDING
WSA_IO_INCOMPLETE	equ ERROR_IO_INCOMPLETE
WSA_INVALID_HANDLE	equ ERROR_INVALID_HANDE
WSA_INVALID_PARAMETER	equ ERROR_INVAID_PARAMETER
WSA_NOT_ENOUGH_MEMORY	equ ERROR_NOT_ENOUGH_MEMORY
WSA_OPERATION_ABORTED	equ ERROR_OPERATION_ABORTED

WSA_INVALID_EVENT	equ 0
WSA_MAXIMUM_WAIT_EVENTS equ MAXIMUM_WAIT_OBJECTS
WSA_WAIT_FAILED		equ -1
WSA_WAIT_EVENT_0	equ WAIT_OBJECT_0
WSA_WAIT_IO_COMPLETION	equ WAIT_IO_COMPLETION
WSA_WAIT_TIMEOUT	equ WAIT_TIMEOUT
WSA_INFINITE		equ INFINITE

endif

WSABUF			STRUC
len			dd ?
buf			LPSTR ?
WSABUF			ENDS
LPWSABUF		typedef ptr WSABUF

if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
include qos.inc
QOS			STRUC
SendingFlowspec		FLOWSPEC <>
ReceivingFlowspec	FLOWSPEC <>
ProviderSpecific	WSABUF <>
QOS			ENDS
LPQOS			typedef ptr QOS
else
LPQOS			typedef ptr
endif

CF_ACCEPT		equ 0x0000
CF_REJECT		equ 0x0001
CF_DEFER		equ 0x0002

SD_RECEIVE		equ 0x00
SD_SEND			equ 0x01
SD_BOTH			equ 0x02

;GROUP			typedef UINT

SG_UNCONSTRAINED_GROUP	equ 0x01
SG_CONSTRAINED_GROUP	equ 0x02

WSANETWORKEVENTS	STRUC
lNetworkEvents		LONG ?
iErrorCode		SINT FD_MAX_EVENTS dup(?)
WSANETWORKEVENTS	ENDS
LPWSANETWORKEVENTS	typedef ptr WSANETWORKEVENTS


ifndef GUID_DEFINED
include guiddef.inc
endif

MAX_PROTOCOL_CHAIN	equ 7

BASE_PROTOCOL		equ 1
LAYERED_PROTOCOL	equ 0

WSAPROTOCOLCHAIN	STRUC
ChainLen		SINT ?
ChainEntries		dd MAX_PROTOCOL_CHAIN dup(?)
WSAPROTOCOLCHAIN	ENDS
LPWSAPROTOCOLCHAIN	typedef ptr WSAPROTOCOLCHAIN

WSAPROTOCOL_LEN		equ 255

if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
WSAPROTOCOL_INFOA	STRUC
dwServiceFlags1		dd ?
dwServiceFlags2		dd ?
dwServiceFlags3		dd ?
dwServiceFlags4		dd ?
dwProviderFlags		dd ?
ProviderId		GUID <>
dwCatalogEntryId	dd ?
ProtocolChain		WSAPROTOCOLCHAIN <>
iVersion		SINT ?
iAddressFamily		SINT ?
iMaxSockAddr		SINT ?
iMinSockAddr		SINT ?
iSocketType		SINT ?
iProtocol		SINT ?
iProtocolMaxOffset	SINT ?
iNetworkByteOrder	SINT ?
iSecurityScheme		SINT ?
dwMessageSize		dd ?
dwProviderReserved	dd ?
szProtocol		db WSAPROTOCOL_LEN+1 dup(?)
WSAPROTOCOL_INFOA	ENDS
LPWSAPROTOCOL_INFOA	typedef ptr WSAPROTOCOL_INFOA
endif

WSAPROTOCOL_INFOW	STRUC
dwServiceFlags1		dd ?
dwServiceFlags2		dd ?
dwServiceFlags3		dd ?
dwServiceFlags4		dd ?
dwProviderFlags		dd ?
ProviderId		GUID <>
dwCatalogEntryId	dd ?
ProtocolChain		WSAPROTOCOLCHAIN <>
iVersion		SINT ?
iAddressFamily		SINT ?
iMaxSockAddr		SINT ?
iMinSockAddr		SINT ?
iSocketType		SINT ?
iProtocol		SINT ?
iProtocolMaxOffset	SINT ?
iNetworkByteOrder	SINT ?
iSecurityScheme		SINT ?
dwMessageSize		dd ?
dwProviderReserved	dd ?
szProtocol		dw WSAPROTOCOL_LEN+1 dup(?)
WSAPROTOCOL_INFOW	ENDS
LPWSAPROTOCOL_INFOW	typedef ptr WSAPROTOCOL_INFOW

ifdef _UNICODE
WSAPROTOCOL_INFO	typedef WSAPROTOCOL_INFOW
LPWSAPROTOCOL_INFO	typedef LPWSAPROTOCOL_INFOW
else
if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
WSAPROTOCOL_INFO	typedef WSAPROTOCOL_INFOA
LPWSAPROTOCOL_INFO	typedef LPWSAPROTOCOL_INFOA
endif
endif

PFL_MULTIPLE_PROTO_ENTRIES	equ 0x00000001
PFL_RECOMMENDED_PROTO_ENTRY	equ 0x00000002
PFL_HIDDEN			equ 0x00000004
PFL_MATCHES_PROTOCOL_ZERO	equ 0x00000008

XP1_CONNECTIONLESS	equ 0x00000001
XP1_GUARANTEED_DELIVERY equ 0x00000002
XP1_GUARANTEED_ORDER	equ 0x00000004
XP1_MESSAGE_ORIENTED	equ 0x00000008
XP1_PSEUDO_STREAM	equ 0x00000010
XP1_GRACEFUL_CLOSE	equ 0x00000020
XP1_EXPEDITED_DATA	equ 0x00000040
XP1_CONNECT_DATA	equ 0x00000080
XP1_DISCONNECT_DATA	equ 0x00000100
XP1_SUPPORT_BROADCAST	equ 0x00000200
XP1_SUPPORT_MULTIPOINT	equ 0x00000400
XP1_MULTIPOINT_CONTROL_PLANE equ 0x00000800
XP1_MULTIPOINT_DATA_PLANE equ 0x00001000
XP1_QOS_SUPPORTED	equ 0x00002000
XP1_INTERRUPT		equ 0x00004000
XP1_UNI_SEND		equ 0x00008000
XP1_UNI_RECV		equ 0x00010000
XP1_IFS_HANDLES		equ 0x00020000
XP1_PARTIAL_MESSAGE	equ 0x00040000
XP1_SAN_SUPPORT_SDP	equ 0x00080000

BIGENDIAN		equ 0x0000
LITTLEENDIAN		equ 0x0001

SECURITY_PROTOCOL_NONE	equ 0x0000

JL_SENDER_ONLY		equ 0x01
JL_RECEIVER_ONLY	equ 0x02
JL_BOTH			equ 0x04

WSA_FLAG_OVERLAPPED	equ 0x01
WSA_FLAG_MULTIPOINT_C_ROOT equ 0x02
WSA_FLAG_MULTIPOINT_C_LEAF equ 0x04
WSA_FLAG_MULTIPOINT_D_ROOT equ 0x08
WSA_FLAG_MULTIPOINT_D_LEAF equ 0x10

WSA_FLAG_ACCESS_SYSTEM_SECURITY equ 0x40
WSA_FLAG_NO_HANDLE_INHERIT equ 0x80
WSA_FLAG_REGISTERED_IO	   equ 0x100

CALLBACK(LPCONDITIONPROC, \
	    lpCallerId: LPWSABUF, \
	  lpCallerData: LPWSABUF, \
		lpSQOS: LPQOS, \
		lpGQOS: LPQOS, \
	    lpCalleeId: LPWSABUF, \
	  lpCalleeData: LPWSABUF, \
		     g: ptr, \ ;GROUP,
	dwCallbackData: DWORD_PTR)

CALLBACK(LPWSAOVERLAPPED_COMPLETION_ROUTINE, \
	       dwError: DWORD, \
	 cbTransferred: DWORD, \
	  lpOverlapped: LPWSAOVERLAPPED, \
	       dwFlags: DWORD)

IOC_UNIX		equ 0x00000000
IOC_WS2			equ 0x08000000
IOC_PROTOCOL		equ 0x10000000
IOC_VENDOR		equ 0x18000000

_WSAIO macro x,y
	exitm<(IOC_VOID OR (x) OR (y))>
	endm
_WSAIOR macro x,y
	exitm<(IOC_OUT OR (x) OR (y))>
	endm
_WSAIOW macro x,y
	exitm<(IOC_IN OR (x) OR (y))>
	endm
_WSAIORW macro x,y
	exitm<(IOC_INOUT OR (x) OR (y))>
	endm

SIO_ASSOCIATE_HANDLE	equ _WSAIOW(IOC_WS2,1)
SIO_ENABLE_CIRCULAR_QUEUEING equ _WSAIO(IOC_WS2,2)
SIO_FIND_ROUTE		equ _WSAIOR(IOC_WS2,3)
SIO_FLUSH		equ _WSAIO(IOC_WS2,4)
SIO_GET_BROADCAST_ADDRESS equ _WSAIOR(IOC_WS2,5)
SIO_GET_EXTENSION_FUNCTION_POINTER equ _WSAIORW(IOC_WS2,6)
SIO_GET_QOS		equ _WSAIORW(IOC_WS2,7)
SIO_GET_GROUP_QOS	equ _WSAIORW(IOC_WS2,8)
SIO_MULTIPOINT_LOOPBACK equ _WSAIOW(IOC_WS2,9)
SIO_MULTICAST_SCOPE	equ _WSAIOW(IOC_WS2,10)
SIO_SET_QOS		equ _WSAIOW(IOC_WS2,11)
SIO_SET_GROUP_QOS	equ _WSAIOW(IOC_WS2,12)
SIO_TRANSLATE_HANDLE	equ _WSAIORW(IOC_WS2,13)
SIO_ROUTING_INTERFACE_QUERY equ _WSAIORW(IOC_WS2,20)
SIO_ROUTING_INTERFACE_CHANGE equ _WSAIOW(IOC_WS2,21)
SIO_ADDRESS_LIST_QUERY	equ _WSAIOR(IOC_WS2,22)
SIO_ADDRESS_LIST_CHANGE equ _WSAIO(IOC_WS2,23)
SIO_QUERY_TARGET_PNP_HANDLE equ _WSAIOR(IOC_W32,24)

if(_WIN32_WINNT GE 0x0501)

SIO_NSP_NOTIFY_CHANGE	equ _WSAIOW(IOC_WS2,25)

WSACOMPLETIONTYPE	typedef sdword
NSP_NOTIFY_IMMEDIATELY	equ 0
NSP_NOTIFY_HWND		equ 1
NSP_NOTIFY_EVENT	equ 2
NSP_NOTIFY_PORT		equ 3
NSP_NOTIFY_APC		equ 4
PWSACOMPLETIONTYPE	typedef ptr WSACOMPLETIONTYPE
LPWSACOMPLETIONTYPE	typedef ptr WSACOMPLETIONTYPE

WSACOMPLETION		STRUC
Type			WSACOMPLETIONTYPE ?
union Parameters
  struct WindowMessage
   hWnd			HWND ?
   uMsg			UINT ?
   context		WPARAM ?
  ends
  struct Event
   lpOverlapped		LPWSAOVERLAPPED ?
  ends
  struct Apc
   lpOverlapped		LPWSAOVERLAPPED ?
   lpfnCompletionProc	LPWSAOVERLAPPED_COMPLETION_ROUTINE ?
  ends
  struct Port
   lpOverlapped		LPWSAOVERLAPPED ?
   hPort		HANDLE ?
   Key			ULONG_PTR ?
  ends
ends
WSACOMPLETION		ENDS
PWSACOMPLETION		typedef ptr WSACOMPLETION
LPWSACOMPLETION		typedef ptr WSACOMPLETION

endif ;; (_WIN32_WINNT GE 0x0501)

TH_NETDEV		equ 0x00000001
TH_TAPI			equ 0x00000002


;sockaddr SOCKADDR;	STRUC
;PSOCKADDR		typedef ptr ; STRUC
;LPSOCKADDR		typedef ptr ;	STRUC

ifndef _tagBLOB_DEFINED
_tagBLOB_DEFINED	equ 1
_BLOB_DEFINED		equ 1
_LPBLOB_DEFINED		equ 1
BLOB			STRUC
cbSize			ULONG ?
pBlobData		LPSTR ?
BLOB			ENDS
LPBLOB			typedef ptr BLOB
endif

SERVICE_MULTIPLE	equ (0x00000001)

NS_ALL			equ (0)
NS_SAP			equ (1)
NS_NDS			equ (2)
NS_PEER_BROWSE		equ (3)
NS_SLP			equ (5)
NS_DHCP			equ (6)
NS_TCPIP_LOCAL		equ (10)
NS_TCPIP_HOSTS		equ (11)
NS_DNS			equ (12)
NS_NETBT		equ (13)
NS_WINS			equ (14)
if(_WIN32_WINNT GE 0x0501)
NS_NLA			equ (15)
endif
if(_WIN32_WINNT GE 0x0600)
NS_BTH			equ (16)
endif
NS_LOCALNAME		equ (19)
NS_NBP			equ (20)
NS_MS			equ (30)
NS_STDA			equ (31)
NS_NTDS			equ (32)
if(_WIN32_WINNT GE 0x0600)
NS_EMAIL		equ (37)
NS_PNRPNAME		equ (38)
NS_PNRPCLOUD		equ (39)
endif
NS_X500			equ (40)
NS_NIS			equ (41)
NS_NISPLUS		equ (42)
NS_WRQ			equ (50)
NS_NETDES		equ (60)


RES_UNUSED_1		equ (0x00000001)
RES_FLUSH_CACHE		equ (0x00000002)
ifndef RES_SERVICE
RES_SERVICE		equ (0x00000004)
endif

SERVICE_TYPE_VALUE_IPXPORTA equ <"IpxSocket">
SERVICE_TYPE_VALUE_IPXPORTW equ <L"IpxSocket">
SERVICE_TYPE_VALUE_SAPIDA   equ <"SapId">
SERVICE_TYPE_VALUE_SAPIDW   equ <L"SapId">
SERVICE_TYPE_VALUE_TCPPORTA equ <"TcpPort">
SERVICE_TYPE_VALUE_TCPPORTW equ <L"TcpPort">
SERVICE_TYPE_VALUE_UDPPORTA equ <"UdpPort">
SERVICE_TYPE_VALUE_UDPPORTW equ <L"UdpPort">
SERVICE_TYPE_VALUE_OBJECTIDA equ <"ObjectId">
SERVICE_TYPE_VALUE_OBJECTIDW equ <L"ObjectId">

ifdef _UNICODE
SERVICE_TYPE_VALUE_SAPID equ SERVICE_TYPE_VAUE_SAPIDW
SERVICE_TYPE_VALUE_TCPPORT equ SERVICE_TYPE_VAUE_TCPPORTW
SERVICE_TYPE_VALUE_UDPPORT equ SERVICE_TYPE_VAUE_UDPPORTW
SERVICE_TYPE_VALUE_OBJECTID equ SERVICE_TYPE_VAUE_OBJECTIDW
else
SERVICE_TYPE_VALUE_SAPID equ SERVICE_TYPE_VAUE_SAPIDA
SERVICE_TYPE_VALUE_TCPPORT equ SERVICE_TYPE_VAUE_TCPPORTA
SERVICE_TYPE_VALUE_UDPPORT equ SERVICE_TYPE_VAUE_UDPPORTA
SERVICE_TYPE_VALUE_OBJECTID equ SERVICE_TYPE_VAUE_OBJECTIDA
endif

ifndef __CSADDR_DEFINED__
__CSADDR_DEFINED__ equ 1

SOCKET_ADDRESS		STRUC
lpSockaddr		LPSOCKADDR ?
iSockaddrLength		SINT ?
SOCKET_ADDRESS		ENDS
PSOCKET_ADDRESS		typedef ptr SOCKET_ADDRESS
LPSOCKET_ADDRESS	typedef ptr SOCKET_ADDRESS

CSADDR_INFO		STRUC
LocalAddr		SOCKET_ADDRESS <>
RemoteAddr		SOCKET_ADDRESS <>
iSocketType		SINT ?
iProtocol		SINT ?
CSADDR_INFO		ENDS
PCSADDR_INFO		typedef ptr CSADDR_INFO
LPCSADDR_INFO		typedef ptr CSADDR_INFO
endif

SOCKET_ADDRESS_LIST	STRUC
iAddressCount		SINT ?
Address			SOCKET_ADDRESS <>
SOCKET_ADDRESS_LIST	ENDS
LPSOCKET_ADDRESS_LIST	typedef ptr SOCKET_ADDRESS_LIST

AFPROTOCOLS		STRUC
iAddressFamily		SINT ?
iProtocol		SINT ?
AFPROTOCOLS		ENDS
PAFPROTOCOLS		typedef ptr AFPROTOCOLS
LPAFPROTOCOLS		typedef ptr AFPROTOCOLS

COMP_EQUAL		equ 0
COMP_NOTLESS		equ 1
WSAECOMPARATOR		typedef LONG
PWSAECOMPARATOR		typedef ptr WSAECOMPARATOR
LPWSAECOMPARATOR	typedef ptr WSAECOMPARATOR

WSAVERSION		STRUC
dwVersion		dd ?
ecHow			WSAECOMPARATOR ?
WSAVERSION		ENDS
PWSAVERSION		typedef ptr WSAVERSION
LPWSAVERSION		typedef ptr WSAVERSION

WSAQUERYSETA		STRUC
dwSize			dd ?
lpszServiceInstanceName LPSTR ?
lpServiceClassId	LPGUID ?
lpVersion		LPWSAVERSION ?
lpszComment		LPSTR ?
dwNameSpace		dd ?
lpNSProviderId		LPGUID ?
lpszContext		LPSTR ?
dwNumberOfProtocols	dd ?
lpafpProtocols		LPAFPROTOCOLS ?
lpszQueryString		LPSTR ?
dwNumberOfCsAddrs	dd ?
lpcsaBuffer		LPCSADDR_INFO ?
dwOutputFlags		dd ?
lpBlob			LPBLOB ?
WSAQUERYSETA		ENDS
PWSAQUERYSETA		typedef ptr WSAQUERYSETA
LPWSAQUERYSETA		typedef ptr WSAQUERYSETA

WSAQUERYSETW		STRUC
dwSize			dd ?
lpszServiceInstanceName LPWSTR ?
lpServiceClassId	LPGUID ?
lpVersion		LPWSAVERSION ?
lpszComment		LPWSTR ?
dwNameSpace		dd ?
lpNSProviderId		LPGUID ?
lpszContext		LPWSTR ?
dwNumberOfProtocols	dd ?
lpafpProtocols		LPAFPROTOCOLS ?
lpszQueryString		LPWSTR ?
dwNumberOfCsAddrs	dd ?
lpcsaBuffer		LPCSADDR_INFO ?
dwOutputFlags		dd ?
lpBlob			LPBLOB ?
WSAQUERYSETW		ENDS
PWSAQUERYSETW		typedef ptr WSAQUERYSETW
LPWSAQUERYSETW		typedef ptr WSAQUERYSETW
ifdef _UNICODE
WSAQUERYSET		typedef WSAQUERYSETW
PWSAQUERYSET		typedef PWSAQUERYSETW
LPWSAQUERYSET		typedef LPWSAQUERYSETW
else
WSAQUERYSET		typedef WSAQUERYSETA
PWSAQUERYSET		typedef PWSAQUERYSETA
LPWSAQUERYSET		typedef LPWSAQUERYSETA
endif

if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

WSAQUERYSET2A		STRUC
dwSize			DWORD ?
lpszServiceInstanceName LPSTR ?
lpVersion		LPWSAVERSION ?
lpszComment		LPSTR ?
dwNameSpace		DWORD ?
lpNSProviderId		LPGUID ?
lpszContext		LPSTR ?
dwNumberOfProtocols	DWORD ?
lpafpProtocols		LPAFPROTOCOLS ?
lpszQueryString		LPSTR ?
dwNumberOfCsAddrs	DWORD ?
lpcsaBuffer		LPCSADDR_INFO ?
dwOutputFlags		DWORD ?
lpBlob			LPBLOB ?
WSAQUERYSET2A		ENDS
PWSAQUERYSET2A		typedef ptr WSAQUERYSET2A
LPWSAQUERYSET2A		typedef ptr WSAQUERYSET2A

WSAQUERYSET2W		STRUC
dwSize			DWORD ?
lpszServiceInstanceName LPWSTR ?
lpVersion		LPWSAVERSION ?
lpszComment		LPWSTR ?
dwNameSpace		DWORD ?
lpNSProviderId		LPGUID ?
lpszContext		LPWSTR ?
dwNumberOfProtocols	DWORD ?
lpafpProtocols		LPAFPROTOCOLS ?
lpszQueryString		LPWSTR ?
dwNumberOfCsAddrs	DWORD ?
lpcsaBuffer		LPCSADDR_INFO ?
dwOutputFlags		DWORD ?
lpBlob			LPBLOB ?
WSAQUERYSET2W		ENDS
PWSAQUERYSET2W		typedef ptr WSAQUERYSET2W
LPWSAQUERYSET2W		typedef ptr WSAQUERYSET2W

ifdef _UNICODE
WSAQUERYSET		typedef WSAQUERYSETW
PWSAQUERYSET		typedef PWSAQUERYSETW
LPWSAQUERYSET		typedef LPWSAQUERYSETW
WSAQUERYSET2		typedef WSAQUERYSET2W
PWSAQUERYSET2		typedef PWSAQUERYSET2W
LPWSAQUERYSET2		typedef LPWSAQUERYSET2W
else
WSAQUERYSET		typedef WSAQUERYSETA
PWSAQUERYSET		typedef PWSAQUERYSETA
LPWSAQUERYSET		typedef LPWSAQUERYSETA
WSAQUERYSET2		typedef WSAQUERYSET2A
PWSAQUERYSET2		typedef PWSAQUERYSET2A
LPWSAQUERYSET2		typedef LPWSAQUERYSET2A
endif

endif ;; WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

LUP_DEEP		equ 0x0001
LUP_CONTAINERS		equ 0x0002
LUP_NOCONTAINERS	equ 0x0004
LUP_NEAREST		equ 0x0008
LUP_RETURN_NAME		equ 0x0010
LUP_RETURN_TYPE		equ 0x0020
LUP_RETURN_VERSION	equ 0x0040
LUP_RETURN_COMMENT	equ 0x0080
LUP_RETURN_ADDR		equ 0x0100
LUP_RETURN_BLOB		equ 0x0200
LUP_RETURN_ALIASES	equ 0x0400
LUP_RETURN_QUERY_STRING equ 0x0800
LUP_RETURN_ALL		equ 0x0FF0
LUP_RES_SERVICE		equ 0x8000
LUP_FLUSHCACHE		equ 0x1000
LUP_FLUSHPREVIOUS	equ 0x2000

LUP_NON_AUTHORITATIVE	equ 0x4000
LUP_SECURE		equ 0x8000
LUP_RETURN_PREFERRED_NAMES equ 0x10000

LUP_ADDRCONFIG		equ 0x00100000
LUP_DUAL_ADDR		equ 0x00200000
LUP_FILESERVER		equ 0x00400000
LUP_DISABLE_IDN_ENCODING equ 0x00800000
LUP_API_ANSI		equ 0x01000000

RESULT_IS_ALIAS		equ 0x0001
if(_WIN32_WINNT GE 0x0501)
RESULT_IS_ADDED		equ 0x0010
RESULT_IS_CHANGED	equ 0x0020
RESULT_IS_DELETED	equ 0x0040
endif

RNRSERVICE_REGISTER	equ 0
RNRSERVICE_DEREGISTER	equ 1
RNRSERVICE_DELETE	equ 2
WSAESETSERVICEOP	typedef LONG
PWSAESETSERVICEOP	typedef ptr WSAESETSERVICEOP
LPWSAESETSERVICEOP	typedef ptr WSAESETSERVICEOP

if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
WSANSCLASSINFOA		STRUC
lpszName		LPSTR ?
dwNameSpace		dd ?
dwValueType		dd ?
dwValueSize		dd ?
lpValue			LPVOID ?
WSANSCLASSINFOA		ENDS
PWSANSCLASSINFOA	typedef ptr WSANSCLASSINFOA
LPWSANSCLASSINFOA	typedef ptr WSANSCLASSINFOA
endif

WSANSCLASSINFOW		STRUC
lpszName		LPWSTR ?
dwNameSpace		dd ?
dwValueType		dd ?
dwValueSize		dd ?
lpValue			LPVOID ?
WSANSCLASSINFOW		ENDS
PWSANSCLASSINFOW	typedef ptr WSANSCLASSINFOW
LPWSANSCLASSINFOW	typedef ptr WSANSCLASSINFOW
ifdef _UNICODE
WSANSCLASSINFO		typedef WSANSCLASSINFOW
PWSANSCLASSINFO		typedef PWSANSCLASSINFOW
LPWSANSCLASSINFO	typedef LPWSANSCLASSINFOW
else
if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
WSANSCLASSINFO		typedef WSANSCLASSINFOA
PWSANSCLASSINFO		typedef PWSANSCLASSINFOA
LPWSANSCLASSINFO	typedef LPWSANSCLASSINFOA
endif
endif

if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
WSASERVICECLASSINFOA	STRUC
lpServiceClassId	LPGUID ?
lpszServiceClassName	LPSTR ?
dwCount			dd ?
lpClassInfos		LPWSANSCLASSINFOA ?
WSASERVICECLASSINFOA	ENDS
PWSASERVICECLASSINFOA	typedef ptr WSASERVICECLASSINFOA
LPWSASERVICECLASSINFOA	typedef ptr WSASERVICECLASSINFOA
endif
WSASERVICECLASSINFOW	STRUC
lpServiceClassId	LPGUID ?
lpszServiceClassName	LPWSTR ?
dwCount			dd ?
lpClassInfos		LPWSANSCLASSINFOW ?
WSASERVICECLASSINFOW	ENDS
PWSASERVICECLASSINFOW	typedef ptr WSASERVICECLASSINFOW
LPWSASERVICECLASSINFOW	typedef ptr WSASERVICECLASSINFOW
ifdef _UNICODE
WSASERVICECLASSINFO	typedef WSASERVICECLASSINFOW
PWSASERVICECLASSINFO	typedef PWSASERVICECLASSINFOW
LPWSASERVICECLASSINFO	typedef LPWSASERVICECLASSINFOW
else
if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
WSASERVICECLASSINFO	typedef WSASERVICECLASSINFOA
PWSASERVICECLASSINFO	typedef PWSASERVICECLASSINFOA
LPWSASERVICECLASSINFO	typedef LPWSASERVICECLASSINFOA
endif
endif

if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
WSANAMESPACE_INFOA	STRUC
NSProviderId		GUID <>
dwNameSpace		dd ?
fActive			BOOL ?
dwVersion		dd ?
lpszIdentifier		LPSTR ?
WSANAMESPACE_INFOA	ENDS
PWSANAMESPACE_INFOA	typedef ptr WSANAMESPACE_INFOA
LPWSANAMESPACE_INFOA	typedef ptr WSANAMESPACE_INFOA
endif

WSANAMESPACE_INFOW	STRUC
NSProviderId		GUID <>
dwNameSpace		dd ?
fActive			BOOL ?
dwVersion		dd ?
lpszIdentifier		LPWSTR ?
WSANAMESPACE_INFOW	ENDS
PWSANAMESPACE_INFOW	typedef ptr WSANAMESPACE_INFOW
LPWSANAMESPACE_INFOW	typedef ptr WSANAMESPACE_INFOW

if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
WSANAMESPACE_INFOEXA	STRUC
NSProviderId		GUID <>
dwNameSpace		dd ?
fActive			BOOL ?
dwVersion		dd ?
lpszIdentifier		LPSTR ?
ProviderSpecific	BLOB <>
WSANAMESPACE_INFOEXA	ENDS
PWSANAMESPACE_INFOEXA	typedef ptr WSANAMESPACE_INFOEXA
LPWSANAMESPACE_INFOEXA	typedef ptr WSANAMESPACE_INFOEXA
endif

WSANAMESPACE_INFOEXW	STRUC
NSProviderId		GUID <>
dwNameSpace		dd ?
fActive			BOOL ?
dwVersion		dd ?
lpszIdentifier		LPWSTR ?
ProviderSpecific	BLOB <>
WSANAMESPACE_INFOEXW	ENDS
PWSANAMESPACE_INFOEXW	typedef ptr WSANAMESPACE_INFOEXW
LPWSANAMESPACE_INFOEXW	typedef ptr WSANAMESPACE_INFOEXW

ifdef _UNICODE
WSANAMESPACE_INFO	typedef WSANAMESPACE_INFOW
PWSANAMESPACE_INFO	typedef PWSANAMESPACE_INFOW
LPWSANAMESPACE_INFO	typedef LPWSANAMESPACE_INFOW
WSANAMESPACE_INFOEX	typedef WSANAMESPACE_INFOEXW
PWSANAMESPACE_INFOEX	typedef PWSANAMESPACE_INFOEXW
LPWSANAMESPACE_INFOEX	typedef LPWSANAMESPACE_INFOEXW
else
if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
WSANAMESPACE_INFO	typedef WSANAMESPACE_INFOA
PWSANAMESPACE_INFO	typedef PWSANAMESPACE_INFOA
LPWSANAMESPACE_INFO	typedef LPWSANAMESPACE_INFOA
WSANAMESPACE_INFOEX	typedef WSANAMESPACE_INFOEXA
PWSANAMESPACE_INFOEX	typedef PWSANAMESPACE_INFOEXA
LPWSANAMESPACE_INFOEX	typedef LPWSANAMESPACE_INFOEXA
endif
endif

if(_WIN32_WINNT GE 0x0600)

POLLRDNORM		equ 0x0100
POLLRDBAND		equ 0x0200
POLLIN			equ (POLLRDNORM or POLLRDBAND)
POLLPRI			equ 0x0400

POLLWRNORM		equ 0x0010
POLLOUT			equ (POLLWRNORM)
POLLWRBAND		equ 0x0020

POLLERR			equ 0x0001
POLLHUP			equ 0x0002
POLLNVAL		equ 0x0004

WSAPOLLFD		STRUC
fd			SOCKET ?
events			sword ?
revents			sword ?
WSAPOLLFD		ENDS
PWSAPOLLFD		typedef ptr WSAPOLLFD
LPWSAPOLLFD		typedef ptr WSAPOLLFD

endif

if INCL_WINSOCK_API_PROTOTYPES
;SOCKET
accept proto WINAPI s:SOCKET, _addr:PVOID, addrlen:ptr SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_ACCEPT, s:SOCKET, _addr:PVOID, addrlen:ptr SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
bind proto WINAPI s:SOCKET, name:PVOID, namelen:SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_BIND, s:SOCKET, name:PVOID, namelen:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
closesocket proto WINAPI s:SOCKET
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_CLOSESOCKET, s:SOCKET)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
connect proto WINAPI s:SOCKET, name:ptr, namelen:SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_CONNECT, s:SOCKET, name:ptr, namelen:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
ioctlsocket proto WINAPI s:SOCKET, cmd:LONG, argp:LPDWORD
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_IOCTLSOCKET, s:SOCKET, cmd:LONG, argp:LPDWORD)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
getpeername proto WINAPI \
		     s: SOCKET,
		  name: PVOID,
	       namelen: ptr SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_GETPEERNAME, s:SOCKET, name:PVOID, namelen:ptr SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
getsockname proto WINAPI \
		     s: SOCKET,
		  name: PVOID,
	       namelen: ptr SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_GETSOCKNAME, s:SOCKET, name:PVOID, namelen:ptr SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
getsockopt proto WINAPI \
		     s: SOCKET,
		 level: SINT,
	       optname: SINT,
		optval: LPSTR,
		optlen: ptr SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_GETSOCKOPT, s:SOCKET, level:SINT, optname:SINT, optval:LPSTR, optlen:ptr SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;DWORD
htonl proto WINAPI \
	      hostlong: DWORD
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_HTONL, hostlong:DWORD)
endif

if INCL_WINSOCK_API_PROTOTYPES
;WORD
htons proto WINAPI \
	     hostshort: WORD
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_HTONS, hostshort:WORD)
endif

if INCL_WINSOCK_API_PROTOTYPES
;DWORD
inet_addr proto WINAPI \
		    cp: LPSTR
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_INET_ADDR, cp:LPSTR)
endif

if INCL_WINSOCK_API_PROTOTYPES
;LPSTR
inet_ntoa proto WINAPI \
		      : in_addr
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_INET_NTOA, :in_addr)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
listen proto WINAPI \
		     s: SOCKET,
	       backlog: SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_LISTEN, s:SOCKET, backlog:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;DWORD
ntohl proto WINAPI \
	       netlong: DWORD
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_NTOHL, netlong:DWORD)
endif

if INCL_WINSOCK_API_PROTOTYPES
;WORD
ntohs proto WINAPI \
	      netshort: WORD
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_NTOHS, netshort:WORD)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
recv proto WINAPI \
		     s: SOCKET,
		   buf: LPSTR,
		   len: SINT,
		 flags: SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_RECV, s:SOCKET, buf:LPSTR, len:SINT, flags:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
recvfrom proto WINAPI \
		     s: SOCKET,
		   buf: LPSTR,
		   len: SINT,
		 flags: SINT,
		  from: PVOID,
	       fromlen: ptr SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_RECVFROM, s:SOCKET, buf:LPSTR, len:SINT, flags:SINT, from:PVOID, fromlen:ptr SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
select proto WINAPI \
		  nfds: SINT,
	       readfds: ptr fd_set,
	      writefds: ptr fd_set,
	     exceptfds: ptr fd_set,
	       timeout: ptr ;struct timeval *
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_SELECT, nfds:SINT, readfds:ptr fd_set, writefds:ptr fd_set, exceptfds:ptr fd_set, timeout:ptr)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
send proto WINAPI \
		     s: SOCKET,
		   buf: LPSTR,
		   len: SINT,
		 flags: SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_SEND, s:SOCKET, buf:LPSTR, len:SINT, flags:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
sendto proto WINAPI \
		     s: SOCKET,
		   buf: LPSTR,
		   len: SINT,
		 flags: SINT,
		    to: PVOID,
		 tolen: SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_SENDTO, s:SOCKET, buf:LPSTR, len:SINT, flags:SINT, to:PVOID, tolen:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
setsockopt proto WINAPI \
		     s: SOCKET,
		 level: SINT,
	       optname: SINT,
		optval: LPSTR,
		optlen: SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_SETSOCKOPT, s:SOCKET, level:SINT, optname:SINT, optval:LPSTR, optlen:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
shutdown proto WINAPI \
		     s: SOCKET,
		   how: SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_SHUTDOWN, s:SOCKET, how:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;SOCKET
socket proto WINAPI \
		    af: SINT,
		  type: SINT,
	      protocol: SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_SOCKET, af:SINT, type:SINT, protocol:SINT)
endif


if INCL_WINSOCK_API_PROTOTYPES
;PVOID
gethostbyaddr proto WINAPI \
		 _addr: LPSTR,
		   len: SINT,
		  type: SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_GETHOSTBYADDR, _addr:LPSTR, len:SINT, type:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;PVOID
gethostbyname proto WINAPI \
		  name: LPSTR
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_GETHOSTBYNAME, name:LPSTR)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
gethostname proto WINAPI \
		  name: LPSTR,
	       namelen: SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_GETHOSTNAME, name:LPSTR, namelen:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;struct
getservbyport proto WINAPI \
		  port: SINT,
		_proto: LPSTR
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_GETSERVBYPORT, port:SINT, _proto:LPSTR)
endif

if INCL_WINSOCK_API_PROTOTYPES
;struct
getservbyname proto WINAPI \
		  name: LPSTR,
		_proto: LPSTR
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_GETSERVBYNAME, name:LPSTR, _proto:LPSTR)
endif

if INCL_WINSOCK_API_PROTOTYPES
;struct
getprotobynumber proto WINAPI \
		number: SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_GETPROTOBYNUMBER, number:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;struct
getprotobyname proto WINAPI \
		  name: LPSTR
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_GETPROTOBYNAME, name:LPSTR)
endif


if INCL_WINSOCK_API_PROTOTYPES
;int
WSAStartup proto WINAPI \
     wVersionRequested: WORD,
	     lpWSAData: LPWSADATA
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSASTARTUP, wVersionRequested:WORD, lpWSAData:LPWSADATA)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSACleanup proto WINAPI
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSACLEANUP)
endif

if INCL_WINSOCK_API_PROTOTYPES
;void
WSASetLastError proto WINAPI \
		iError: SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSASETLASTERROR, iError:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSAGetLastError proto WINAPI
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAGETLASTERROR)
endif

if INCL_WINSOCK_API_PROTOTYPES
;BOOL
WSAIsBlocking proto WINAPI
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAISBLOCKING)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSAUnhookBlockingHook proto WINAPI
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAUNHOOKBLOCKINGHOOK)
endif

if INCL_WINSOCK_API_PROTOTYPES
;FARPROC
WSASetBlockingHook proto WINAPI \
	   lpBlockFunc: FARPROC
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSASETBLOCKINGHOOK, lpBlockFunc:FARPROC)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSACancelBlockingCall proto WINAPI
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSACANCELBLOCKINGCALL)
endif

if INCL_WINSOCK_API_PROTOTYPES
;HANDLE
WSAAsyncGetServByName proto WINAPI \
		  hWnd: HWND,
		  wMsg: UINT,
		  name: LPSTR,
		_proto: LPSTR,
		   buf: LPSTR,
		buflen: SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAASYNCGETSERVBYNAME, hWnd:HWND, wMsg:UINT, name:LPSTR, _proto:LPSTR, buf:LPSTR, buflen:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;HANDLE
WSAAsyncGetServByPort proto WINAPI \
		  hWnd: HWND,
		  wMsg: UINT,
		  port: SINT,
		_proto: LPSTR,
		   buf: LPSTR,
		buflen: SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAASYNCGETSERVBYPORT, hWnd:HWND, wMsg:UINT, port:SINT, _proto:LPSTR, buf:LPSTR, buflen:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;HANDLE
WSAAsyncGetProtoByName proto WINAPI \
		  hWnd: HWND,
		  wMsg: UINT,
		  name: LPSTR,
		   buf: LPSTR,
		buflen: SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAASYNCGETPROTOBYNAME, hWnd:HWND, wMsg:UINT, name:LPSTR, buf:LPSTR, buflen:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;HANDLE
WSAAsyncGetProtoByNumber proto WINAPI \
		  hWnd: HWND,
		  wMsg: UINT,
		number: SINT,
		   buf: LPSTR,
		buflen: SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAASYNCGETPROTOBYNUMBER, hWnd:HWND, wMsg:UINT, number:SINT, buf:LPSTR, buflen:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;HANDLE
WSAAsyncGetHostByName proto WINAPI \
		  hWnd: HWND,
		  wMsg: UINT,
		  name: LPSTR,
		   buf: LPSTR,
		buflen: SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAASYNCGETHOSTBYNAME, hWnd:HWND, wMsg:UINT, name:LPSTR, buf:LPSTR, buflen:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;HANDLE
WSAAsyncGetHostByAddr proto WINAPI \
		  hWnd: HWND,
		  wMsg: UINT,
		 _addr: LPSTR,
		   len: SINT,
		  type: SINT,
		   buf: LPSTR,
		buflen: SINT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAASYNCGETHOSTBYADDR, hWnd:HWND, wMsg:UINT, addr:LPSTR, len:SINT, type:SINT, buf:LPSTR, buflen:SINT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSACancelAsyncRequest proto WINAPI \
      hAsyncTaskHandle: HANDLE
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSACANCELASYNCREQUEST, hAsyncTaskHandle:HANDLE)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSAAsyncSelect proto WINAPI \
		     s: SOCKET,
		  hWnd: HWND,
		  wMsg: UINT,
		lEvent: LONG
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAASYNCSELECT, s:SOCKET, hWnd:HWND, wMsg:UINT, lEvent:LONG)
endif

CALLBACK(LPWSAOVERLAPPED_COMPLETION_ROUTINE, :DWORD, :DWORD, :LPWSAOVERLAPPED, :DWORD)

if INCL_WINSOCK_API_PROTOTYPES
;SOCKET
WSAAccept proto WINAPI \
		     s: SOCKET,
		 _addr: PVOID,
	       addrlen: LPINT,
	 lpfnCondition: LPCONDITIONPROC,
	dwCallbackData: DWORD
endif

if INCL_WINSOCK_API_TYPEDEFS
WSAAccept proto WINAPI \
		     s: SOCKET,
		 _addr: PVOID,
	       addrlen: LPINT,
	 lpfnCondition: LPCONDITIONPROC,
	dwCallbackData: DWORD
LPFN_WSAACCEPT typedef ptr LPFN_WSAACCEPT_T
endif

if INCL_WINSOCK_API_PROTOTYPES
;BOOL
WSACloseEvent proto WINAPI \
		hEvent: WSAEVENT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSACLOSEEVENT, hEvent:WSAEVENT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSAConnect proto WINAPI \
		     s: SOCKET,
		  name: PVOID,
	       namelen: SINT,
	  lpCallerData: LPWSABUF,
	  lpCalleeData: LPWSABUF,
		lpSQOS: LPQOS,
		lpGQOS: LPQOS
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSACONNECT, s:SOCKET, name:PVOID, namelen:SINT, \
	lpCallerData:LPWSABUF, lpCalleeData:LPWSABUF, lpSQOS:LPQOS, lpGQOS:LPQOS)
endif

if INCL_WINSOCK_API_PROTOTYPES
;WSAEVENT
WSACreateEvent proto WINAPI
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSACREATEEVENT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSADuplicateSocketA proto WINAPI \
		     s: SOCKET,
	   dwProcessId: DWORD,
	lpProtocolInfo: LPWSAPROTOCOL_INFOA
;int
WSADuplicateSocketW proto WINAPI \
		     s: SOCKET,
	   dwProcessId: DWORD,
	lpProtocolInfo: LPWSAPROTOCOL_INFOW
ifdef _UNICODE
WSADuplicateSocket	equ <WSADuplicateSocketW>
else
WSADuplicateSocket	equ <WSADuplicateSocketA>
endif
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSADUPLICATESOCKETA, :SOCKET, :DWORD, :LPWSAPROTOCOL_INFOA)
CALLBACK(LPFN_WSADUPLICATESOCKETW, :SOCKET, :DWORD, :LPWSAPROTOCOL_INFOW)
ifdef _UNICODE
LPFN_WSADUPLICATESOCKET equ <LPFN_WSADUPLICATESOCKETW>
else
LPFN_WSADUPLICATESOCKET equ <LPFN_WSADUPLICATESOCKETA>
endif
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSAEnumNetworkEvents proto WINAPI \
		     s: SOCKET,
	  hEventObject: WSAEVENT,
       lpNetworkEvents: LPWSANETWORKEVENTS
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAENUMNETWORKEVENTS, :SOCKET, :WSAEVENT, :LPWSANETWORKEVENTS)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSAEnumProtocolsA proto WINAPI \
	  lpiProtocols: LPINT,
      lpProtocolBuffer: LPWSAPROTOCOL_INFOA,
      lpdwBufferLength: LPDWORD
;int
WSAEnumProtocolsW proto WINAPI \
	  lpiProtocols: LPINT,
      lpProtocolBuffer: LPWSAPROTOCOL_INFOW,
      lpdwBufferLength: LPDWORD
ifdef _UNICODE
WSAEnumProtocols	equ <WSAEnumProtocolsW>
else
WSAEnumProtocols	equ <WSAEnumProtocolsA>
endif
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAENUMPROTOCOLSA, :LPINT, :LPWSAPROTOCOL_INFOA, :LPDWORD)
CALLBACK(LPFN_WSAENUMPROTOCOLSW, :LPINT, :LPWSAPROTOCOL_INFOW, :LPDWORD)
ifdef _UNICODE
LPFN_WSAENUMPROTOCOLS	equ <LPFN_WSAENUMPROTOCOLSW>
else
LPFN_WSAENUMPROTOCOLS	equ <LPFN_WSAENUMPROTOCOLSA>
endif
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSAEventSelect proto WINAPI \
		     s: SOCKET,
	  hEventObject: WSAEVENT,
	lNetworkEvents: LONG
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAEVENTSELECT, :SOCKET, hEventObject:WSAEVENT, lNetworkEvents:LONG)
endif

if INCL_WINSOCK_API_PROTOTYPES
;BOOL
WSAGetOverlappedResult proto WINAPI \
		     s: SOCKET,
	  lpOverlapped: LPWSAOVERLAPPED,
	  lpcbTransfer: LPDWORD,
		_fWait: BOOL,
	     lpdwFlags: LPDWORD
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAGETOVERLAPPEDRESULT, :SOCKET, :LPWSAOVERLAPPED, :LPDWORD, :BOOL, :LPDWORD)
endif

if INCL_WINSOCK_API_PROTOTYPES
;BOOL
WSAGetQOSByName proto WINAPI \
		     s: SOCKET,
	     lpQOSName: LPWSABUF,
		 lpQOS: LPQOS
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAGETQOSBYNAME, :SOCKET, :LPWSABUF, :LPQOS)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSAHtonl proto WINAPI \
		     s: SOCKET,
	      hostlong: DWORD,
	     lpnetlong: LPDWORD
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAHTONL, :SOCKET, :DWORD, :LPDWORD)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSAHtons proto WINAPI \
		     s: SOCKET,
	     hostshort: WORD,
	    lpnetshort: LPWORD
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAHTONS, :SOCKET, :WORD, :LPWORD)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSAIoctl proto WINAPI \
		     s: SOCKET,
       dwIoControlCode: DWORD,
	   lpvInBuffer: LPVOID,
	    cbInBuffer: DWORD,
	  lpvOutBuffer: LPVOID,
	   cbOutBuffer: DWORD,
     lpcbBytesReturned: LPDWORD,
	  lpOverlapped: LPWSAOVERLAPPED,
   lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAIOCTL, :SOCKET, :DWORD, :LPVOID, :DWORD, :LPVOID, :DWORD, :LPDWORD, :LPWSAOVERLAPPED,	:LPWSAOVERLAPPED_COMPLETION_ROUTINE)
endif

if INCL_WINSOCK_API_PROTOTYPES
;SOCKET
WSAJoinLeaf proto WINAPI \
		     s: SOCKET,
		  name: PVOID,
	       namelen: SINT,
	  lpCallerData: LPWSABUF,
	  lpCalleeData: LPWSABUF,
		lpSQOS: LPQOS,
		lpGQOS: LPQOS,
	       dwFlags: DWORD
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAJOINLEAF, :SOCKET, :PVOID, :SINT, :LPWSABUF, :LPWSABUF, :LPQOS, :LPQOS, :DWORD)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSANtohl proto WINAPI \
		     s: SOCKET,
	       netlong: DWORD,
	    lphostlong: LPDWORD
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSANTOHL, :SOCKET, :DWORD, :LPDWORD)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSANtohs proto WINAPI \
		     s: SOCKET,
	      netshort: WORD,
	   lphostshort: LPWORD
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSANTOHS, :SOCKET, :WORD, :LPWORD)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSARecv proto WINAPI \
		     s: SOCKET,
	     lpBuffers: LPWSABUF,
	 dwBufferCount: DWORD,
  lpNumberOfBytesRecvd: LPDWORD,
	       lpFlags: LPDWORD,
	  lpOverlapped: LPWSAOVERLAPPED,
   lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSARECV, :SOCKET, :LPWSABUF, :DWORD, :LPDWORD, :LPDWORD, :LPWSAOVERLAPPED, :LPWSAOVERLAPPED_COMPLETION_ROUTINE)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSARecvDisconnect proto WINAPI \
		     s: SOCKET,
lpInboundDisconnectData: LPWSABUF
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSARECVDISCONNECT,:SOCKET, :LPWSABUF)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSARecvFrom proto WINAPI \
		     s: SOCKET,
	     lpBuffers: LPWSABUF,
	 dwBufferCount: DWORD,
  lpNumberOfBytesRecvd: LPDWORD,
	       lpFlags: LPDWORD,
		lpFrom: PVOID,
	     lpFromlen: LPINT,
	  lpOverlapped: LPWSAOVERLAPPED,
   lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSARECVFROM, :SOCKET, :LPWSABUF, :DWORD, :LPDWORD, :LPDWORD, :PVOID, :LPINT, :LPWSAOVERLAPPED, :LPWSAOVERLAPPED_COMPLETION_ROUTINE)
endif

if INCL_WINSOCK_API_PROTOTYPES
;BOOL
WSAResetEvent proto WINAPI \
		hEvent: WSAEVENT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSARESETEVENT, :WSAEVENT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSASend proto WINAPI \
		     s: SOCKET,
	     lpBuffers: LPWSABUF,
	 dwBufferCount: DWORD,
   lpNumberOfBytesSent: LPDWORD,
	       dwFlags: DWORD,
	  lpOverlapped: LPWSAOVERLAPPED,
   lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSASEND, :SOCKET, :LPWSABUF, :DWORD, :LPDWORD, :DWORD, :LPWSAOVERLAPPED, :LPWSAOVERLAPPED_COMPLETION_ROUTINE)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSASendDisconnect proto WINAPI \
		     s: SOCKET,
lpOutboundDisconnectData: LPWSABUF
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSASENDDISCONNECT, :SOCKET, :LPWSABUF)
endif

if INCL_WINSOCK_API_PROTOTYPES
;int
WSASendTo proto WINAPI \
		     s: SOCKET,
	     lpBuffers: LPWSABUF,
	 dwBufferCount: DWORD,
   lpNumberOfBytesSent: LPDWORD,
	       dwFlags: DWORD,
		  lpTo: PVOID,
		iTolen: SINT,
	  lpOverlapped: LPWSAOVERLAPPED,
   lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSASENDTO, :SOCKET, :LPWSABUF, :DWORD, :LPDWORD, :DWORD, :PVOID, :SINT, :LPWSAOVERLAPPED, :LPWSAOVERLAPPED_COMPLETION_ROUTINE)
endif

if INCL_WINSOCK_API_PROTOTYPES
;BOOL
WSASetEvent proto WINAPI \
		hEvent: WSAEVENT
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSASETEVENT, :WSAEVENT)
endif

if INCL_WINSOCK_API_PROTOTYPES
;SOCKET
WSASocketA proto WINAPI \
		    af: SINT,
		  type: SINT,
	      protocol: SINT,
	lpProtocolInfo: LPWSAPROTOCOL_INFOA,
		     g: UINT,
	       dwFlags: DWORD
;SOCKET
WSASocketW proto WINAPI \
		    af: SINT,
		  type: SINT,
	      protocol: SINT,
	lpProtocolInfo: LPWSAPROTOCOL_INFOW,
		     g: UINT,
	       dwFlags: DWORD
ifdef _UNICODE
WSASocket		equ <WSASocketW>
else
WSASocket		equ <WSASocketA>
endif
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSASOCKETA, :SINT, :SINT, :SINT, :LPWSAPROTOCOL_INFOA, :UINT, :DWORD)
CALLBACK(LPFN_WSASOCKETW, :SINT, :SINT, :SINT, :LPWSAPROTOCOL_INFOW, :UINT, :DWORD)
ifdef _UNICODE
LPFN_WSASOCKET		equ <LPFN_WSASOCKETW>
else
LPFN_WSASOCKET		equ <LPFN_WSASOCKETA>
endif
endif

if INCL_WINSOCK_API_PROTOTYPES
;DWORD
WSAWaitForMultipleEvents proto WINAPI \
	       cEvents: DWORD,
	     lphEvents: ptr WSAEVENT,
	      fWaitAll: BOOL,
	     dwTimeout: DWORD,
	    fAlertable: BOOL
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAWAITFORMULTIPLEEVENTS, :DWORD, :ptr WSAEVENT, :BOOL, :DWORD, :BOOL)
endif

if INCL_WINSOCK_API_PROTOTYPES
;INT
WSAAddressToStringA proto WINAPI \
	   lpsaAddress: LPSOCKADDR,
       dwAddressLength: DWORD,
	lpProtocolInfo: LPWSAPROTOCOL_INFOA,
     lpszAddressString: LPSTR,
lpdwAddressStringLength: LPDWORD
;INT
WSAAddressToStringW proto WINAPI \
	   lpsaAddress: LPSOCKADDR,
       dwAddressLength: DWORD,
	lpProtocolInfo: LPWSAPROTOCOL_INFOW,
     lpszAddressString: LPWSTR,
lpdwAddressStringLength: LPDWORD
ifdef _UNICODE
WSAAddressToString	equ <WSAAddressToStringW>
else
WSAAddressToString	equ <WSAAddressToStringA>
endif
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAADDRESSTOSTRINGA, :LPSOCKADDR, :DWORD, :LPWSAPROTOCOL_INFOA, :LPSTR, :LPDWORD)
CALLBACK(LPFN_WSAADDRESSTOSTRINGW, :LPSOCKADDR, :DWORD, :LPWSAPROTOCOL_INFOW, :LPWSTR, :LPDWORD)
ifdef _UNICODE
LPFN_WSAADDRESSTOSTRING equ <LPFN_WSAADDRESSTOSTRINGW>
else
LPFN_WSAADDRESSTOSTRING equ <LPFN_WSAADDRESSTOSTRINGA>
endif
endif

if INCL_WINSOCK_API_PROTOTYPES
;INT
WSAStringToAddressA proto WINAPI \
	 AddressString: LPSTR,
	 AddressFamily: SINT,
	lpProtocolInfo: LPWSAPROTOCOL_INFOA,
	     lpAddress: LPSOCKADDR,
       lpAddressLength: LPINT
;INT
WSAStringToAddressW proto WINAPI \
	 AddressString: LPWSTR,
	 AddressFamily: SINT,
	lpProtocolInfo: LPWSAPROTOCOL_INFOW,
	     lpAddress: LPSOCKADDR,
       lpAddressLength: LPINT
ifdef _UNICODE
WSAStringToAddress	equ <WSAStringToAddressW>
else
WSAStringToAddress	equ <WSAStringToAddressA>
endif
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSASTRINGTOADDRESSA, :LPSTR, :SINT, :LPWSAPROTOCOL_INFOA, :LPSOCKADDR, :LPINT)
CALLBACK(LPFN_WSASTRINGTOADDRESSW, :LPWSTR, :SINT, :LPWSAPROTOCOL_INFOW, :LPSOCKADDR, :LPINT)
ifdef _UNICODE
LPFN_WSASTRINGTOADDRESS equ <LPFN_WSASTRINGTOADDRESSW>
else
LPFN_WSASTRINGTOADDRESS equ <LPFN_WSASTRINGTOADDRESSA>
endif
endif

if INCL_WINSOCK_API_PROTOTYPES
;INT
WSALookupServiceBeginA proto WINAPI \
      lpqsRestrictions: LPWSAQUERYSETA,
	dwControlFlags: DWORD,
	     lphLookup: LPHANDLE
;INT
WSALookupServiceBeginW proto WINAPI \
      lpqsRestrictions: LPWSAQUERYSETW,
	dwControlFlags: DWORD,
	     lphLookup: LPHANDLE
ifdef _UNICODE
WSALookupServiceBegin	equ <WSAookupServiceBeginW>
else
WSALookupServiceBegin	equ <WSAookupServiceBeginA>
endif
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSALOOKUPSERVICEBEGINA, :LPWSAQUERYSETA, :DWORD, :LPHANDLE)
CALLBACK(LPFN_WSALOOKUPSERVICEBEGINW, :LPWSAQUERYSETW, :DWORD, :LPHANDLE)
ifdef _UNICODE
LPFN_WSALOOKUPSERVICEBEGIN equ <LPFN_WSAOOKUPSERVICEBEGINW>
else
LPFN_WSALOOKUPSERVICEBEGIN equ <LPFN_WSAOOKUPSERVICEBEGINA>
endif
endif

if INCL_WINSOCK_API_PROTOTYPES
;INT
WSALookupServiceNextA proto WINAPI \
	       hLookup: HANDLE,
	dwControlFlags: DWORD,
      lpdwBufferLength: LPDWORD,
	   lpqsResults: LPWSAQUERYSETA
;INT
WSALookupServiceNextW proto WINAPI \
	       hLookup: HANDLE,
	dwControlFlags: DWORD,
      lpdwBufferLength: LPDWORD,
	   lpqsResults: LPWSAQUERYSETW
ifdef _UNICODE
WSALookupServiceNext	equ <WSAookupServiceNextW>
else
WSALookupServiceNext	equ <WSAookupServiceNextA>
endif
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSALOOKUPSERVICENEXTA, :HANDLE, :DWORD, :LPDWORD, :LPWSAQUERYSETA)
CALLBACK(LPFN_WSALOOKUPSERVICENEXTW, :HANDLE, :DWORD, :LPDWORD, :LPWSAQUERYSETW)
ifdef _UNICODE
LPFN_WSALOOKUPSERVICENEXT equ <LPFN_WSAOOKUPSERVICENEXTW>
else
LPFN_WSALOOKUPSERVICENEXT equ <LPFN_WSAOOKUPSERVICENEXTA>
endif
endif

if INCL_WINSOCK_API_PROTOTYPES
;INT
WSALookupServiceEnd proto WINAPI \
	       hLookup: HANDLE
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSALOOKUPSERVICEEND, :HANDLE)
endif

if INCL_WINSOCK_API_PROTOTYPES
;INT
WSAInstallServiceClassA proto WINAPI \
    lpServiceClassInfo: LPWSASERVICECLASSINFOA
;INT
WSAInstallServiceClassW proto WINAPI \
    lpServiceClassInfo: LPWSASERVICECLASSINFOW
ifdef _UNICODE
WSAInstallServiceClass	equ <WSAInstallServiceClassW>
else
WSAInstallServiceClass	equ <WSAInstallServiceClassA>
endif
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAINSTALLSERVICECLASSA, :LPWSASERVICECLASSINFOA)
CALLBACK(LPFN_WSAINSTALLSERVICECLASSW, :LPWSASERVICECLASSINFOW)
ifdef _UNICODE
LPFN_WSAINSTALLSERVICECLASS equ <LPFN_WSAINSTALLSERVICECASSW>
else
LPFN_WSAINSTALLSERVICECLASS equ <LPFN_WSAINSTALLSERVICECASSA>
endif
endif

if INCL_WINSOCK_API_PROTOTYPES
;INT
WSARemoveServiceClass proto WINAPI \
      lpServiceClassId: LPGUID
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAREMOVESERVICECLASS, :LPGUID)
endif

if INCL_WINSOCK_API_PROTOTYPES
;INT
WSAGetServiceClassInfoA proto WINAPI \
	  lpProviderId: LPGUID,
      lpServiceClassId: LPGUID,
	   lpdwBufSize: LPDWORD,
    lpServiceClassInfo: LPWSASERVICECLASSINFOA
;INT
WSAGetServiceClassInfoW proto WINAPI \
	  lpProviderId: LPGUID,
      lpServiceClassId: LPGUID,
	   lpdwBufSize: LPDWORD,
    lpServiceClassInfo: LPWSASERVICECLASSINFOW
ifdef _UNICODE
WSAGetServiceClassInfo	equ <WSAGetServiceClassInfoW>
else
WSAGetServiceClassInfo	equ <WSAGetServiceClassInfoA>
endif
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAGETSERVICECLASSINFOA, :LPGUID, :LPGUID, :LPDWORD, :LPWSASERVICECLASSINFOA)
CALLBACK(LPFN_WSAGETSERVICECLASSINFOW, :LPGUID, :LPGUID, :LPDWORD, :LPWSASERVICECLASSINFOW)
ifdef _UNICODE
LPFN_WSAGETSERVICECLASSINFO equ <LPFN_WSAGETSERVICECASSINFOW>
else
LPFN_WSAGETSERVICECLASSINFO equ <LPFN_WSAGETSERVICECASSINFOA>
endif
endif

if INCL_WINSOCK_API_PROTOTYPES
;INT
WSAEnumNameSpaceProvidersA proto WINAPI \
      lpdwBufferLength: LPDWORD,
	   lpnspBuffer: LPWSANAMESPACE_INFOA
;INT
WSAEnumNameSpaceProvidersW proto WINAPI \
      lpdwBufferLength: LPDWORD,
	   lpnspBuffer: LPWSANAMESPACE_INFOW
ifdef _UNICODE
WSAEnumNameSpaceProviders equ <WSAEnumNameSpaceProvidersW>
else
WSAEnumNameSpaceProviders equ <WSAEnumNameSpaceProvidersA>
endif
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAENUMNAMESPACEPROVIDERSA, :LPDWORD, :LPWSANAMESPACE_INFOA)
CALLBACK(LPFN_WSAENUMNAMESPACEPROVIDERSW, :LPDWORD, :LPWSANAMESPACE_INFOW)
ifdef _UNICODE
LPFN_WSAENUMNAMESPACEPROVIDERS equ <LPFN_WSAENUMNAMESPACEPROVIDERSW>
else
LPFN_WSAENUMNAMESPACEPROVIDERS equ <LPFN_WSAENUMNAMESPACEPROVIDERSA>
endif
endif

if INCL_WINSOCK_API_PROTOTYPES
;INT
WSAGetServiceClassNameByClassIdA proto WINAPI \
      lpServiceClassId: LPGUID,
  lpszServiceClassName: LPSTR,
      lpdwBufferLength: LPDWORD
;INT
WSAGetServiceClassNameByClassIdW proto WINAPI \
      lpServiceClassId: LPGUID,
  lpszServiceClassName: LPWSTR,
      lpdwBufferLength: LPDWORD
ifdef _UNICODE
WSAGetServiceClassNameByClassId equ <WSAGetServiceClassNameByClassIdW>
else
WSAGetServiceClassNameByClassId equ <WSAGetServiceClassNameByClassIdA>
endif
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA, :LPGUID, :LPSTR, :LPDWORD)
CALLBACK(LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW, :LPGUID, :LPWSTR, :LPDWORD)
ifdef _UNICODE
LPFN_WSAGETSERVICECLASSNAMEBYCLASSID equ <LPFN_WSAGETSERVICECLASSNAMEBYCASSIDW>
else
LPFN_WSAGETSERVICECLASSNAMEBYCLASSID equ <LPFN_WSAGETSERVICECLASSNAMEBYCASSIDA>
endif
endif

if INCL_WINSOCK_API_PROTOTYPES
;INT
WSASetServiceA proto WINAPI \
	   lpqsRegInfo: LPWSAQUERYSETA,
	  essoperation: WSAESETSERVICEOP,
	dwControlFlags: DWORD
;INT
WSASetServiceW proto WINAPI \
	   lpqsRegInfo: LPWSAQUERYSETW,
	  essoperation: WSAESETSERVICEOP,
	dwControlFlags: DWORD
ifdef _UNICODE
WSASetService		equ <WSASetServiceW>
else
WSASetService		equ <WSASetServiceA>
endif
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSASETSERVICEA, :LPWSAQUERYSETA, :WSAESETSERVICEOP, :DWORD)
CALLBACK(LPFN_WSASETSERVICEW, :LPWSAQUERYSETW, :WSAESETSERVICEOP, :DWORD)
ifdef _UNICODE
LPFN_WSASETSERVICE	equ <LPFN_WSASETSERVICEW>
else
LPFN_WSASETSERVICE	equ <LPFN_WSASETSERVICEA>
endif
endif

if INCL_WINSOCK_API_PROTOTYPES
;INT
WSAProviderConfigChange proto WINAPI \
  lpNotificationHandle: LPHANDLE,
	  lpOverlapped: LPWSAOVERLAPPED,
   lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE
endif

if INCL_WINSOCK_API_TYPEDEFS
CALLBACK(LPFN_WSAPROVIDERCONFIGCHANGE, :LPHANDLE, :LPWSAOVERLAPPED, :LPWSAOVERLAPPED_COMPLETION_ROUTINE)
endif

if(_WIN32_WINNT GE 0x0600)
if INCL_WINSOCK_API_PROTOTYPES
WSAPoll proto WINAPI fdArray:LPWSAPOLLFD, fds:ULONG, timeout:SINT
endif
endif

;sockaddr_in SOCKADDR_IN; STRUC
;PSOCKADDR_IN		typedef PVOID
;LPSOCKADDR_IN		typedef PVOID

;linger LINGER;		STRUC
PLINGER			typedef PVOID
LPLINGER		typedef PVOID

;in_addr IN_ADDR;	STRUC
;PIN_ADDR		typedef PVOID
;LPIN_ADDR		typedef PVOID

;fd_set FD_SET;		STRUC
;PFD_SET			typedef PVOID
;LPFD_SET		typedef PVOID

;hostent HOSTENT;	STRUC
PHOSTENT		typedef PVOID
LPHOSTENT		typedef PVOID

;SERVENT;	STRUC
PSERVENT		typedef PVOID
LPSERVENT		typedef PVOID

;protoent PROTOENT;	STRUC
PPROTOENT		typedef PVOID
LPPROTOENT		typedef PVOID

;timeval TIMEVAL;	STRUC
PTIMEVAL		typedef PVOID
LPTIMEVAL		typedef PVOID

WSAMAKEASYNCREPLY macro buflen,error
	exitm<MAKELONG(buflen,error)>
	endm
WSAMAKESELECTREPLY macro event,error
	exitm<MAKELONG(event,error)>
	endm
WSAGETASYNCBUFLEN macro lParam
	exitm<LOWORD(lParam)>
	endm
WSAGETASYNCERROR macro lParam
	exitm<HIWORD(lParam)>
	endm
WSAGETSELECTEVENT macro lParam
	exitm<LOWORD(lParam)>
	endm
WSAGETSELECTERROR macro lParam
	exitm<HIWORD(lParam)>
	endm


ifdef _NEED_POPPACK
.pragma pack(pop)
endif

if(_WIN32_WINNT GE 0x0501)
ifdef IPV6STRICT
include wsipv6ok.inc
endif
endif

endif
